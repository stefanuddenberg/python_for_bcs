# 8.7 Common Patterns

Now that we've covered the basics of the Python language, this section aggregates common code patterns you'll use and
encounter frequently. Think of these as ready-to-use templates that you can adapt for your specific needs. You don't
have to memorize them all or read through this section in one go — think of this more like a cheat sheet.

## Anonymous functions

Lambda functions or anonymous functions (see [Chapter 3.0. Functions](../CH03/3.0.%20Functions.md) for a refresher) provide a way
to create small, single-expression functions inline. They're particularly useful when you need a simple function as an
argument to another function. Below I'll outline some common patterns for using lambda functions.

### Sorting with lambda functions

```python
# Sort strings by length
words = ['python', 'is', 'awesome']
sorted_words = sorted(words, key=lambda x: len(x))  # ['is', 'python', 'awesome']

# Sort dictionaries by a specific field
users = [
    {'name': 'Alice', 'age': 25, 'grade': 'C'},
    {'name': 'Bob', 'age': 30, 'grade': 'B'},
    {'name': 'Charlie', 'age': 20, 'grade': 'A'}
]
sorted_users = sorted(users, key=lambda x: x['age'])  # Sorts by age

# Using lambda function to extract specific fields from a dictionary
user_tuples = list(map(lambda x: (x['name'], x['age'], x['grade']), users))

# Alternative using list comprehension (more idiomatic/Pythonic)
user_tuples = [(user['name'], user['age'], user['grade']) for user in users]


# Result: [('Alice', 25, 'C'), ('Bob', 30, 'B'), ('Charlie', 20, 'A')]
# Sort by age first, then by grade
sorted_users = sorted(users, key=lambda x: (x['age'], x['grade'])) # for dictionaries
sorted_user_tuples = sorted(user_tuples, key=lambda name, age, grade: (age, grade)) # for tuples

# You can do the same thing with an underscore as the first argument, because we don't actually care about the name
# The underscore is a convention for indicating that the value is not used
sorted_user_tuples = sorted(user_tuples, key=lambda _, age, grade: (age, grade)) # same as the previous example

# Sort complex objects
from dataclasses import dataclass

@dataclass
class Person:
    name: str
    age: int
    grade: str


people = [
    Person('Alice', 25, 'A'),
    Person('Bob', 30, 'B'),
    Person('Charlie', 20, 'C')
]

# Sort by age
sorted_people = sorted(people, key=lambda x: x.age)
# Sort by multiple criteria: grade first, then by age
sorted_people = sorted(people, key=lambda x: (x.grade, x.age))
```

### As simple transformations

Lambda functions are often used when we need to transform data from one format to another in very straightforward ways.

```python
# Quick data conversion
to_celsius = lambda f: (f - 32) * 5/9
to_fahrenheit = lambda c: (c * 9/5) + 32

# Simple mathematical operations
square = lambda x: x**2
add = lambda x, y: x + y

# Format strings
format_name = lambda first, last: f"{last.upper()}, {first.title()}"
```

### With default arguments

You can also use default arguments in lambda functions, just like you would with regular functions.

```python
# Lambda with default values
greeting = lambda name, greeting="Hello": f"{greeting}, {name}!"
print(greeting("Alice"))  # "Hello, Alice!"
print(greeting("Bob", "Hi"))  # "Hi, Bob!"

# Conditional logic
get_status = lambda x: "Pass" if x >= 60 else "Fail"
```

## Functional programming patterns

In addition to the Object-Oriented Programming paradigm (as via classes), Python supports several functional programming
patterns via built-in functions like `map()`, `filter()`, and `reduce()`. While list comprehensions are often preferred
in Python, these patterns are still useful to know.

### Transforming data with `map()`

The `map()` function is useful when you need to apply a function to each item in a collection. Think of it as a very concise
version of a for loop. It says, "For each item in the collection, apply the function to it and return the result".

```python
# Convert temperatures from Celsius to Fahrenheit
celsius = [0, 10, 20, 30]
# we cast the result to a list because map returns an iterator
fahrenheit = list(map(lambda c: (c * 9/5) + 32, celsius))

# Format strings in a list — make everything title case
names = ['alice', 'bob', 'charlie']
formatted = list(map(lambda x: x.title(), names)) # "Alice", "Bob", "Charlie"
```

### Filtering data with `filter()`

The `filter()` function is useful when you need to filter items in a collection based on a condition. It says, "For each item in the collection, get me the items that match the condition and return them in a new collection".

```python
# Filter out negative numbers
numbers = [-2, -1, 0, 1, 2]
positives = list(filter(lambda x: x > 0, numbers)) # [1, 2]

# Filter dictionaries by condition
items = [
    {'name': 'apple', 'price': 0.50},
    {'name': 'banana', 'price': 0.25},
    {'name': 'cherry', 'price': 1.00}
]
affordable_items = list(filter(lambda x: x['price'] < 0.75, items))
# gives us: [{'name': 'apple', 'price': 0.50}, {'name': 'banana', 'price': 0.25}]
```

### Combining with `reduce()`

The `reduce()` function from the `functools` module is used to process a sequence or collection and build a single
result by applying a function to pairs of elements. It works by:

1. Taking the first two items from the sequence
2. Applying the function to them to get an intermediate result
3. Taking that result and the next item from the sequence
4. Repeating until all items are processed

Here's an example of how reduce works with multiplication, multiplying all the numbers in a list together:

```python
from functools import reduce

numbers = [1, 2, 3, 4]
# Get the product of all numbers in the list using `reduce`
# reduce(lambda x, y: x * y, numbers) works like this:
# Step 1: 1 * 2 = 2
# Step 2: 2 * 3 = 6
# Step 3: 6 * 4 = 24
product = reduce(lambda x, y: x * y, numbers)  # Result: 24

# You can also provide an initial value as a third argument
product = reduce(lambda x, y: x * y, numbers, 10)  # Starts with 10, result: 240
```

While Python has several built-in functions that can be used to reduce collections in specific ways (e.g. `sum()`,
`join()`, etc.), `reduce()` is a more general purpose method that can be used to reduce any collection. You will see it
used from time to time.

```python
from functools import reduce

# Sum all numbers in a list (though the sum() built-in is preferred)
total = reduce(lambda x, y: x + y, [1, 2, 3, 4])  # 10

# Join strings with a separator (though the join() built-in is preferred)
words = ['hello', 'world', 'in', 'python']
sentence = reduce(lambda x, y: x + ' ' + y, words)  # "hello world in python"

# Find maximum value in a list of dictionaries (though max() built-in is preferred)
transactions = [
    {'amount': 100},
    {'amount': 200},
    {'amount': 150}
]
max_transaction = reduce(lambda x, y: x if x['amount'] > y['amount'] else y, transactions)
# Returns: {'amount': 200}
```

## Counting and aggregating

Often, you'll need to _count_ things: how many times does a particular item appear in a list, how many unique items are
in a list, how many times does an event occur, etc. There are many ways to do so:

### Counting items

```python
from collections import Counter

# Count occurrences in a list
words = ['apple', 'banana', 'apple', 'cherry']
word_counts = Counter(words)  # Counter({'apple': 2, 'banana': 1, 'cherry': 1})

# Count with a dictionary
counts = {}
for item in items:
    counts[item] = counts.get(item, 0) + 1

# Using defaultdict
from collections import defaultdict
counts = defaultdict(int)
for item in items:
    counts[item] += 1
```

### Finding the most (or least) common items

```python
word_counts = Counter(words)
# Get the 3 most common words and their counts
three_most_common_words = word_counts.most_common(3)

# Get the least common word and its count
# Notice how we still use the most_common method, but we choose the last item
# which is now the least common one
least_common_word = word_counts.most_common()[-1]
```

### Finding the biggest and smallest items

#### In dictionaries

```python
# Convert Counter to a dictionary
counts = dict(word_counts)

# Find the key associated with the maximum value in a dictionary
word_with_most_occurrences = max(counts, key=counts.get)

# Find the key associated with the minimum value in a dictionary
word_with_least_occurrences = min(counts, key=counts.get)
```

#### In lists

```python
# Find the smallest value in a list
numbers = [1, 2, 3, 4, 5]
smallest_number = min(numbers)

# Find the largest value in a list
largest_number = max(numbers)

# Find the index of the smallest value in a list
smallest_number_index = numbers.index(smallest_number)

# Find the index of the largest value in a list
largest_number_index = numbers.index(largest_number)
```

#### In tuples

Suppose that you have a list of tuples, where each tuple contains something and a number. You can use the `min` and `max` functions to find the smallest and largest items, respectively.

```python
items = [("apple", 1), ("banana", 2), ("cherry", 3)]
smallest_item = min(items, key=lambda item: item[1])
largest_item = max(items, key=lambda item: item[1])

# You can also use tuple unpacking if you prefer, since this is a little more readable
smallest_item = min(items, key=lambda name, count: count)
largest_item = max(items, key=lambda name, count: count)
```

#### In objects

```python
class Car:
    def __init__(self, brand, model, year, mileage=None):
        self.brand = brand
        self.model = model
        self.year = year
        self.mileage = mileage or 0 # initialize odometer to 0 if no mileage is provided

    def drive(self, miles):
        self.mileage += miles

    def __str__(self):
        return f"{self.brand} {self.model} ({self.year}): Driven {self.mileage} miles"

cars = [
    Car("Toyota", "Corolla", 2020, 10000),
    Car("Ford", "Mustang", 2021, 5000),
    Car("Chevrolet", "Camaro", 2022, 2000),
]

# Find the car with the most miles
car_with_most_miles = max(cars, key=lambda x: x.mileage)

# Find the car with the least miles
car_with_least_miles = min(cars, key=lambda x: x.mileage)
```

## Working with files

We often need to read and write files in our programs. For example, we might need to read a configuration file, or load
in data via a CSV file or a text file. Here are some common ways to work with files.

### Reading files

```python
# Read entire file — note the use of a context manager (the `with` statement)
# This ensures that the file is properly closed after its block finishes, even if an exception is raised at some point
with open('file.txt', 'r') as f:
    content = f.read()

# Read line by line
with open('file.txt', 'r') as f:
    for line in f:
        line = line.strip()  # Remove trailing newlines and whitespace characters
        # Logic for processing line goes here

# Read CSV files
import csv
with open('data.csv', 'r') as f:
    reader = csv.reader(f)
    for row in reader:
        # Logic for processing row goes here
```

### Writing files

```python
# Write lines to a file
lines = ['line 1', 'line 2', 'line 3']
with open('output.txt', 'w') as f:
    for line in lines:
        f.write(f"{line}\n")

# Write CSV files
with open('output.csv', 'w', newline='') as f:
    writer = csv.writer(f)
    writer.writerows(data)
```

## Data transformation

Much of the job of a researcher is to transform some messy data into a more usable format. Rarely are the data you need
already pre-processed for you. As such, getting comfortable with data transformation is a crucial skill. You may find
yourself relying on these operations frequently.

### Filtering lists

```python
# Filter with list comprehension
numbers = [1, 2, 3, 4, 5, 6]
evens = [x for x in numbers if x % 2 == 0]

# Filter with built-in filter function
evens = list(filter(lambda x: x % 2 == 0, numbers))
```

### Transforming data

```python
# Transform and filter in one step
numbers = [1, 2, 3, 4, 5]
squared_evens = [x**2 for x in numbers if x % 2 == 0]

# Transform dictionary values
prices = {'apple': 0.5, 'banana': 0.25}
doubled_prices = {k: v * 2 for k, v in prices.items()}
```

## Working with nested data

Data is often nested (meaning that you have a dictionary or list that contains another dictionary or list, and so on,
potentially to a great depth), and you may need to access or transform nested data — I do this all the time, and these
are some of the ways I do it.

### Safely accessing nested dictionaries

```python
# Using get() with default values
data = {'user': {'name': 'John', 'age': 30}}
name = data.get('user', {}).get('name', 'Unknown')
# we do this to avoid a KeyError, which would occur
# if we tried to access data['user']['name'] directly if the key is not present

# Or we could use a try-except block (but this is less readable)
try:
    name = data['user']['name']
except KeyError:
    name = 'Unknown'
```

### Flattening nested lists

Sometimes you may need to flatten a list of lists into a single list. You can do this with a list comprehension or with
the `itertools` module.

```python
# Flatten a list of lists
nested = [[1, 2], [3, 4], [5, 6]]
flattened = [item for sublist in nested for item in sublist] # [1, 2, 3, 4, 5, 6]

# Flatten with itertools
import itertools
flattened = list(itertools.chain.from_iterable(nested)) # [1, 2, 3, 4, 5, 6]
```

## Error handling

Errors are a fact of life in programming. You can't always predict when they'll occur, but you can prepare for them, and
handle them gracefully with try-except blocks. Review [Chapter 2.10. Try and Except](../CH02/2.10.%20Try%20and%20Except.md) if any
of this is unfamiliar.

### Graceful error handling

It's not a good idea to catch all exceptions with a bare `except` clause. Instead, specify the exceptions you expect to
handle, and catch the rest with a more general `except` clause that also logs the error.

```python
# Handle multiple exceptions
try:
    value = int(user_input)
    result = 100 / value
except ValueError:
    print("Please enter a valid number")
except ZeroDivisionError:
    print("Cannot divide by zero")
except Exception as e:
    print(f"An unexpected error occurred: {e}")
```

## Working with dates and times

Dates and times are a fact of life in many scientific and engineering applications. Within my own work in psychology, I
have to deal with when participants completed my tasks, their reaction times when making responses, and so on. May you
find these examples helpful.

### Date manipulation

```python
from datetime import datetime, timedelta

# Get current date/time
now = datetime.now()

# Add/subtract time
tomorrow = now + timedelta(days=1)
last_week = now - timedelta(weeks=1)

# Format dates
formatted = now.strftime("%Y-%m-%d %H:%M:%S")
```

These patterns represent common solutions to several frequently encountered programming tasks. While there are often
multiple ways to solve a problem, these are well-worn patterns, providing tested, readable approaches that you can build
upon.

Next: TODO<br>
[Previous: 8.6. Decorators](8.6.%20Decorators.md)
