# 8.6 Decorators

So far, we've encountered functions that return variables (such as integers, strings, lists, and so on) or nothing at
all. However, because functions are "first-class citizens" in Python, they can do much more — they can be passed as
arguments to other functions, stored in variables, and even returned from other functions. This means a function can
create and return _another function_, just like it can create and return a number or a string.

Think of it this way: if a function can create a number (like `def give_me_a_five(): return 5`), it can also create a
function (like `def make_greeting(): return lambda: "Hello"`). This ability to treat functions like any other value is
what makes _decorators_ possible.

Decorators are a way to modify or enhance functions without directly changing their source code. You can think of them
as "wrappers" that add extra functionality around your existing functions. They use a special `@` symbol syntax that
makes them easy to apply and read.

Some common uses for decorators include, but are not limited to:

- Adding logging before and after a function runs (you'll see an example of this in 8.3 with `pysnooper`)
- Measuring how long a function takes to execute (as with a timer)
- Checking if a user has permission to run a function (as with an access control decorator)
- Saving (or _caching_) function results to make accessing those results faster next time

## Basic decorator syntax

Let's see how a decorator works by looking at a simple example:

```python
def my_decorator(func):
    def wrapper():
        print("Something is happening before the function is called.")
        func()
        print("Something is happening after the function is called.")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()
```

When you run this code, the output will be:

```text
Something is happening before the function is called.
Hello!
Something is happening after the function is called.
```

The `@my_decorator` syntax is equivalent to writing:

```python
say_hello = my_decorator(say_hello)
```

## Decorators with arguments

Decorators can also accept arguments from the functions they wrap:

```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print(f"About to call {func.__name__}")
        result = func(*args, **kwargs) # call the decorated function and save the result
        print(f"Finished calling {func.__name__}")
        return result
    return wrapper

@my_decorator
def greet(name):
    print(f"Hello, {name}!")

greet("Alice")
```

Notice the use of `*args` and `**kwargs` in the wrapper function. This allows the decorator to work with functions that
take any number of positional and/or keyword arguments. You'll see this pattern used a lot with wrapper functions, as
they are essentially a bridge between the decorator and the function it is decorating — the arguments must flow through
the wrapper to get to the decorated function.

## Real-world examples

These are some of the more common real-world examples I've come across while developing Python applications.

### Timing functions

Here's a practical decorator that measures how long a function takes to execute:

```python
import time

def timer(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs) # evaluate the function
        end_time = time.time()
        print(f"{func.__name__} took {end_time - start_time:.2f} seconds to run")
        return result
    return wrapper

@timer
def slow_function():
    time.sleep(1)
    print("Function finished!")
```

### Caching results

Counting the fibonacci sequence is a classic example of a function that is well suited to caching. The naive recursive
implementation is very slow for large values of `n`, but the cached version is extremely fast. Let's look at the naïve (slow) version first:

```python
def fibonacci(n):
    if n < 2:  # Base cases: fib(0) = 0, fib(1) = 1
        return n
    return fibonacci(n-1) + fibonacci(n-2)
```

If you try to run this function for large values of `n`, you'll notice that it takes a long time to complete. This
implementation is considered "naïve" because it recalculates the same values many times. For example, to calculate
`fibonacci(5)`, it will calculate `fibonacci(2)` three separate times! This redundant calculation makes it slower and
slower the bigger the `n` you give it. Now, let's try storing the results of the function for future use in a dictionary
so that we don't have to recalculate them:

```python
def cache(func):
    stored_results = {}

    def wrapper(*args):
        if args in stored_results:
            return stored_results[args]
        result = func(*args)
        stored_results[args] = result
        return result
    return wrapper

@cache
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
```

Now if we use this decorated version of the same code, it will be considerably faster.

## Class decorators

Decorators are not limited to functions — they can also be used with classes:

```python
def singleton(cls):
    instances = {}

    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]

    return get_instance

@singleton
class Configuration:
    def __init__(self):
        self.settings = {}
```

In this case, the `@singleton` decorator ensures that only one instance of the `Configuration` class is created and
shared across the program.

## Built-in decorators

The Python standard library provides several built-in decorators:

### `@property`

Sometimes you need to compute attributes of objects on the fly, and it would be helpful to access them as attributes
instead of as methods, since it can be somewhat more ergonomic:

```python
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def area(self):
        return 3.14 * self._radius ** 2

circle = Circle(5)
print(circle.area)  # Accessed like an attribute, not circle.area()
```

## Summary

Decorators are a powerful way to modify or enhance functions and classes in Python. They allow you to add functionality
to existing code progressively, without needing to change what you've already written very much. It's relatively
unlikely that you will need to write your own decorators for this particular class, but at the very least I hope you are
now a more savvy consumer of this feature.

[Next: TODO]<br>
Previous: [8.5. Asking Good Questions](8.5.%20Asking%20Good%20Questions.md)<br>
