# 20.5. Setting Up the Database

Now that we've defined our survey data model using SQLModel, we can actually create a real database
on your computer's hard drive and start saving participant responses to it.

We will use **SQLite**, which is a lightweight database that stores everything in a single file. It
is perfect for small demos, local development, and many real research projects. (In production, out
on the web, we would typically use a more robust database like PostgreSQL.)

## Step 0: Decide where the database file should live

In this chapter, we'll keep things simple and store the database file in the root project folder;
the same folder as `main.py`. Let's call it `survey.db`.

SQLite will create this file for us automatically when we first connect to the database.

## Step 1: Create a database engine

Next, we will need a way to connect to the database. We will do this by creating a new file in your
root project folder called `database.py` (again, next to `main.py`) and adding the following code:

```python
from sqlmodel import SQLModel, create_engine

# This is a "connection string" that tells SQLModel/SQLAlchemy to use SQLite and store the database
# in a file named survey.db in the current folder.
sqlite_url = "sqlite:///survey.db"

# `echo=True` prints SQL statements to the terminal. Note that we
# don't need to do this in production, as it will slow down the server, but we do it here
# for learning and debugging purposes.
engine = create_engine(sqlite_url, echo=True)

def create_db_and_tables() -> None:
    """
    Create the database tables based on any SQLModel classes with `table=True`.
    """
    SQLModel.metadata.create_all(engine)
```

## Step 2: Create the tables from our SQLModel classes

Remember: tables are created only from the classes where you used `table=True` (in our case,
`SurveyResponse`).

To make sure SQLModel knows about that table, we need to import it before we create the tables.

Update the top of `main.py` to include the following imports, which will allow us to create the
database tables:

```python
from database import create_db_and_tables
from models import * # This will import all the SQLModel classes from models.py

# rest of app here...
```

Lastly, we will call `create_db_and_tables()` when the app starts. The simplest way to do this would
be to import it at the top of `main.py` and then run it inline. However, a better (but slightly more
complicated) way is to use the **lifespan** feature of FastAPI, like so:

```python
# first, we import the asynccontextmanager from the contextlib module
# at the top of main.py
from contextlib import asynccontextmanager

# rest of imports here...

# then, we can define a lifespan context manager
# that will run the create_db_and_tables() function when the app starts

@asynccontextmanager
async def lifespan(app: FastAPI):
    # The code below runs on startup
    create_db_and_tables()
    yield
    # Any code below here would run on shutdown
    # but we don't have any cleanup to do here,
    # so we can just leave it empty
```

Finally, make sure you pass that lifespan function into your FastAPI app:

```python
app = FastAPI(lifespan=lifespan)
```

Now, any time the app starts anew, the `create_db_and_tables()` function will be called.

After you restart the app with `uvicorn`, you should see SQL statements printed in the terminal and
a `survey.db` file appear in your project folder.

## Step 3: Open a database session (so we can insert rows)

Now we will need a way to open a session to the database, so we can make changes to it. Update the
top import statement in your `database.py` file to include `Session` from `sqlmodel`, as well as the
`Generator` type hint from `typing`, then create a `get_session()` function that returns a new
`Session` object:

```python
from sqlmodel import SQLModel, create_engine, Session
from typing import Generator


def get_session() -> Generator[Session, None, None]:
    """
    Returns a generator yielding a new Session object.
    This is a context manager that will automatically close the session when the block finishes.
    """
    with Session(engine) as session:
        yield session
```

This creates a `Session`, which is how we talk to the database: insert rows, query rows, etc. (Don't
worry too much about the `Generator` type hint here — the important thing is that it will give us a
Session object. We could have written a much simpler function that just returned a `Session`
directly, but this way we won't have to worry about closing the session manually.)

## Step 4: Save a survey response when the participant clicks Submit

Now we can update our `/submit` route in `main.py` so that it creates a `SurveyResponse` and saves
it to the database. We will use the `get_session()` function to open a session to the database, and
then use the `session` object to insert the new response into the database. However, we will do so with a helpful feature in FastAPI: **dependency injection**.

First, let's update our imports at the top of `main.py` to ensure we have everything we need.

```python
# These should be all the imports you need for now
from contextlib import asynccontextmanager

from fastapi import FastAPI, Request, Depends
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates

from sqlmodel import Session

from database import create_db_and_tables, get_session
from models import SurveyResponse, SurveyResponseOut
from typing import Any
```

Then update your `/submit` route to be the following:

```python
# We're adding a new parameter to the submit_survey function — `session: Session = Depends(get_session)`
# This means that the session object will be automatically created and passed to the function.
@app.post("/submit", response_class=HTMLResponse)
async def submit_survey(request: Request, session: Session = Depends(get_session)):
    form = await request.form()

    tipi_extraverted_raw = cast_to_string(form.get("tipi_extraverted")).strip()
    tipi_reserved_quiet_raw = cast_to_string(form.get("tipi_reserved_quiet")).strip()
    comments = cast_to_string(form.get("comments")).strip() or None

    response = SurveyResponse(
        tipi_extraverted=int(tipi_extraverted_raw),
        tipi_reserved_quiet=int(tipi_reserved_quiet_raw),
        comments=comments,
    )

    # Add the response to the session, commit the changes,
    # and refresh the response object
    session.add(response)
    session.commit()
    session.refresh(response)

    return templates.TemplateResponse(
        request=request,
        name="thank_you.html",
        context={
            "request": request,
            "tipi_extraverted": response.tipi_extraverted,
            "tipi_reserved_quiet": response.tipi_reserved_quiet,
            "comments": response.comments,
        },
    )
```

Now each time a participant submits the form, their response is saved to `survey.db`. This is
accomplished by using the `session` object to add the response to the session, commit the changes,
and refresh the response object.

> [!TIP]
>
> ### Why do we bother calling `session.refresh(response)`?
>
> You may think our work is done after we add and commit the response. However, refreshing can be
> useful, as it updates the Python object with any server-generated values (like `id` and
> `created_at`) that the database filled in, making it easier to work with as a developer. If you
> didn't call `refresh(response)`, you would not have access to those server-generated values in the
> Python object itself.

## Step 5: Add a route to quickly view the saved data

It's often helpful to add an "experimenter view" route while you're building the survey.

Here's a simple JSON endpoint you can add to `main.py` to view the saved data:

```python
# other imports above here...
from sqlmodel import select


@app.get("/responses", response_model=list[SurveyResponseOut])
def list_responses(session: Session = Depends(get_session)):
    responses = session.exec(select(SurveyResponse)).all()
    return responses
```

There's one more trick being done in that function: we're declaring the `response_model` to be a
list of `SurveyResponseOut` objects. This is a helpful feature of FastAPI that will automatically
convert the list of `SurveyResponse` objects into a list of `SurveyResponseOut` objects, which is
what we actually want to return to the client/web browser. If you visit
`http://127.0.0.1:8000/responses`, you should now see a JSON list of stored responses. And if you
make any changes to the `SurveyResponseOut` class, those changes will be reflected in the responses
you see. For example, we can add the `id` field to the `SurveyResponseOut` class, and the responses
you see will now include the `id` field. Right now, the responses are sanitized to remove that
information, even though the original `SurveyResponse` objects still have that field (thanks,
FastAPI!).

## Conclusion

At last, we have a complete minimal experiment pipeline! We now have:

- A simple HTML form for the participant to fill out and submit
- A FastAPI app that can receive the form submission
- Functions that use SQLModel to validate/type the data and save it to the database
- The ability to view the saved data via a JSON endpoint

There are many other features we could add down the road, including exporting the database to CSV;
password-protected administrator pages; a dashboard for us to monitor the experiment's progress; and
so on. But the code we've written so far provides all the basic functionality we need to get started
with running a survey on the web (minus deployment, for which there are many options).

<!-- GITHUB-NAV-START -->

Next: [20.6. Lab 20](20.6.%20Lab%2020.md)<br>
Previous: [20.4. Modeling Survey Data with SQLModel](20.4.%20Modeling%20Survey%20Data%20with%20SQLModel.md)

<!-- GITHUB-NAV-END -->
