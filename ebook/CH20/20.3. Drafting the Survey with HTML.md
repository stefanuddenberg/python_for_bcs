# 20.3. Drafting the survey with HTML

In [the previous section](20.2.%20A%20Simple%20FastAPI%20App.md), we built a tiny FastAPI server and
learned about routes/endpoints by returning simple JSON responses. However, we would like to have our server return something a participant can actually _use_.

In this section, we will build the frontend of our survey using a plain HTML form. When the participant visits our server, they will see a page with a few questions, hit Submit, and then see a simple "thank you" page.

This is just for drafting purposes, so we won't store any data yet â€” that is its own kettle of fish. For now, we just want to send form data from the browser to the server, to have the participant "communicate" in some sense with our server. (We'll handle data validation and storage in the next section.)

## Step 1: Ensure Jinja2 and Python-Multipart are installed

FastAPI can serve HTML pages using templates. We'll use **Jinja2**, which is the most common
templating library in Python. If you haven't already installed them, be sure to install Jinja2 and Python-Multipart.

```bash
uv add jinja2 python-multipart
```

## Step 2: Create a `templates/` folder to store our HTML templates

In the same folder as your `main.py`, create a folder named `templates`.

Your project folder should look like this:

```text
bcog200_web/
  main.py
  templates/
```

## Step 3: Create HTML templates in `templates/`

Alas, in order to make a frontend, we will need to write some HTML. Though we won't go into the
details of HTML here, you can learn about it at your leisure on
[w3schools](https://www.w3schools.com/html/). For our purposes, all you need to know is that it's a
simple markup language for displaying content in a web browser. Think of it as a more complicated
version of Markdown that uses opening tags (e.g., `<div>`, `<p>`, `<h1>`, `<h2>`, etc.) and closing
tags (e.g., `</div>`, `</p>`, `</h1>`, `</h2>`, etc.) to define the structure of the page. These
tags also have various attributes that you can define.

For now, create a file called `survey.html` inside your `templates/` folder and add the following
content to it (you can just copy/paste this directly). This is a tiny survey based on the **Ten Item
Personality Inventory (TIPI)**. For demo purpsoses, we'll only use **two** of the TIPI statements (plus an optional
comments question).

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>BCOG 200 Demo TIPI Survey</title>
  </head>
  <body>
    <h1>Demo TIPI Survey</h1>

    <p>
      Here are a number of personality traits that may or may not apply to you.
      Please rate on a scale of 1 to 7 to indicate the extent to which you agree
      or disagree with that statement. You should rate the extent to which the
      pair of traits applies to you, even if one characteristic applies more
      strongly than the other.
    </p>

    <form method="post" action="/submit">
      <div>
        <p><strong>I see myself as:</strong> Extraverted, enthusiastic.</p>
        <label for="tipi_extraverted">Rating:</label>
        <select id="tipi_extraverted" name="tipi_extraverted" required>
          <option value="" selected>Please select an option</option>
          <option value="1">1 (disagree strongly)</option>
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4 (neither agree nor disagree)</option>
          <option value="5">5</option>
          <option value="6">6</option>
          <option value="7">7 (agree strongly)</option>
        </select>
      </div>

      <div>
        <p><strong>I see myself as:</strong> Reserved, quiet.</p>
        <label for="tipi_reserved_quiet">Rating:</label>
        <select id="tipi_reserved_quiet" name="tipi_reserved_quiet" required>
          <option value="" selected>Please select an option</option>
          <option value="1">1 (disagree strongly)</option>
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4 (neither agree nor disagree)</option>
          <option value="5">5</option>
          <option value="6">6</option>
          <option value="7">7 (agree strongly)</option>
        </select>
      </div>

      <div>
        <label for="comments">Any additional comments? (optional)</label><br />
        <textarea id="comments" name="comments" rows="4" cols="60"></textarea>
      </div>

      <button type="submit">Submit</button>
    </form>
  </body>
</html>
```

This page displays a form with two Likert-style questions (1-7) and an optional open-ended comments
box. We've made the Likert scale questions required, so the participant cannot submit the form
without answering them.

A few other notes:

- The `action="/submit"` means: "send this form to the `/submit` endpoint on our server".
- The `method="post"` means: "send it as a POST request (not a GET request)".
- The `name="XXX"` attributes are the ways we can refer to the input fields on the server

If you open the file directly on your computer using your web browser, you should see a very simple page with the form. Of course, it won't do anything yet, as we haven't added any logic to the server to handle the form data.

While we're at it, let's create a template for the "Thank you" page. Create a file called
`thank_you.html` inside your `templates/` folder and add the following content:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Thank you</title>
  </head>
  <body>
    <h1>Thank you!</h1>
    <p>Your response was received.</p>
    <h2>Debug view (to be removed later)</h2>
    <ul>
      <li>tipi_extraverted: {{ tipi_extraverted }}</li>
      <li>tipi_reserved_quiet: {{ tipi_reserved_quiet }}</li>
      <li>comments: {{ comments }}</li>
    </ul>
  </body>
</html>
```

In addition to run-of-the-mill static HTML, this page also uses Jinja2 templating syntax to display
the submitted data in a dynamic fashion. This type of templating is denoted by the use of double
curly braces, like `{{ tipi_extraverted }}`. This means "insert the value of `tipi_extraverted` from
the context dictionary provided to the template". And the context dictionary is the dictionary of
variables that is passed to the template when it is rendered (we'll see how that works in the next
couple of steps).

We are going to show the submitted values only as a means of making our debugging easier for now. In
a real survey, you usually would not echo the participant's answers back to them unless you have a
reason to do so, but it's quite common to use this sort of templating to provide custom feedback or
debriefing to the participant.

## Step 4: Update `main.py` to serve the survey page

Now we need to ensure that our server can show this HTML page to the participant when they visit,
and then save the data when they submit the form. Let's add it to the root of our server.

We're going to update our `main.py` file with a new route that serves the HTML page for now. Later,
we will add another that receives the form data and shows a thank-you page. We will also need to add
a couple of imports to the top of the file to handle some of this functionality.

```python
from fastapi import FastAPI, Request
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates

app = FastAPI()

templates = Jinja2Templates(directory="templates")


@app.get("/", response_class=HTMLResponse)
def survey_form(request: Request):
    return templates.TemplateResponse(
        request=request,
        name="survey.html",
        context={"request": request},
    )
```

As you can imagine, this new `survey_form()` function returns the rendered template `survey.html` to
the participant when they visit the root of our server. Visit the root of your server in your
browser (e.g., `http://127.0.0.1:8000/`) to see the form. You should even see the form has some
basic input validation, but pressing the "Submit" button will take you to a page that doesn't have a
route we defined yet (yielding a "{detail: 'Not Found'}" JSON response). We'll fix this in the next
step.

## Step 5: Handle the form submission

Next, let's add a route that receives the form data and shows the "Thank you" page with the details
of the submitted data, just as a sanity check to make sure everything is working. Below our previous
route, add the following:

```python
@app.post("/submit", response_class=HTMLResponse)
async def submit_survey(request: Request):
    form = await request.form()

    # Get the form data and remove any whitespace
    # from the beginning/end of the strings
    tipi_extraverted_raw = (form.get("tipi_extraverted") or "").strip()
    tipi_reserved_quiet_raw = (form.get("tipi_reserved_quiet") or "").strip()
    comments = (form.get("comments") or "").strip()

    # Convert the data to the appropriate types
    tipi_extraverted = int(tipi_extraverted_raw) if tipi_extraverted_raw else None
    tipi_reserved_quiet = int(tipi_reserved_quiet_raw) if tipi_reserved_quiet_raw else None

        request=request,
        name="thank_you.html",
        context={equest=request,
        name="thank_you.html",
        context={
            "request": request,
            "tipi_extraverted": tipi_extraverted,
            "tipi_reserved_quiet": tipi_reserved_quiet,
            "comments": comments,
        },
    )
```

There are a few new things to note here. First, we are associating this route with a POST request,
rather than a GET request (as shown by the `@app.post("/submit", response_class=HTMLResponse)`
decorator). HTML requests have a handful of different methods or "verbs" that dictate how the data
is sent to the server. GET requests are used to _retrieve_ data from the server (as with our
function. This type of function stands in contrast to "sychronous" functions, which are the default
verbs as well, such as PUT, DELETE, and PATCH.) Second, we have defined this route to use an `async`
function. This type of function stands in contrast to "synchronous" functions, which are the default
type of function, and the only type we have written so far in this course.

So what's the difference between these two types of functions?

- In a _synchronous_ function (`def`), Python runs the code step-by-step, and if it hits an
  operation that needs to wait (for example, waiting for data to arrive from the network), that
  function blocks execution until it's done.
- In an _asynchronous_ function (`async def`), the function is allowed to _pause_ at specific points
  using `await`. While it is paused, the server can go do other work (like handling another request
  from another browser tab). When the paused operation is done, the function resumes execution.
  Writing asynchronous functions is a little more complicated, but it keeps the server responsive
  and able to handle multiple requests at once.

In our case, the key line that requires us to use an asynchronous function is:

`form = await request.form()`

Reading/parsing the incoming form body is implemented as an asynchronous operation in FastAPI, so we
must use the `await` keyword to pause and wait for that data to come in. Any time you need to use
the `await` keyword, you must make the function `async def`.

A few other important details:

- The `request: Request` parameter in the function definition is required for templates to work properly
- Everything arrives as strings, so we handle type conversion ourselves (for now).

## Step 6: Run the server and test the survey

Now we're ready to try out our survey! In your terminal, run the same command you used to start the
server in the previous section:

```bash
uvicorn main:app --reload
```

Then visit the root of your server in your browser (e.g., `http://127.0.0.1:8000/`) to see the survey form.

Fill out the form and submit it. You should see the "Thank you" page with the details of the
submitted data!

## Troubleshooting

### "RuntimeError: Form data requires 'python-multipart'"

As the error message suggests, you need to install the `python-multipart` package.

```bash
uv add python-multipart
```

### "TemplateNotFound: survey.html"

Make sure you created a `templates/` folder in the same place as `main.py` and that the HTML file is
exactly named `survey.html` and exists within that `templates/` folder.

## What comes next?

We can now send participant responses from the browser to our server. Next, we'll define our data
model using SQLModel and save each submission to a real database.

Next: [20.4. Modeling Survey Data with SQLModel](20.4.%20Modeling%20Survey%20Data%20with%20SQLModel.md)<br>
Previous: [20.2. A Simple FastAPI App](20.2.%20A%20Simple%20FastAPI%20App.md)
