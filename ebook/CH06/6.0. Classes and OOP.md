# 6.0. Classes and Object-Oriented Programming

We're ready for our last topic in our Python crash course before we move on to some Brain and
Cognitive Science applications. Without further ado, let's dive into classes.

## Object-oriented languages

Python is what is called an _object-oriented language_. This means that the design of Python is organized around objects.
Almost every data structure in Python is an object. Lists, dictionaries, strings, integers, floats, sets - these are all
objects. Objects are data structures that allow you to bundle together variables and functions.

Take the humble list, for example: there is the data in the list (e.g., `[1, 2, 3]`), and then there
are the methods you can use on the list (e.g., `.append()` and `.sort()`).

Object-oriented languages can be contrasted with _functional languages_. In a functional language,
most of the code exists as functions that take objects as inputs, but are not themselves a part of
the objects.

If you reflect on what we've been learning, you'll see that almost everything we've learned to do
involves objects and their methods, like `.append()` for lists and `.mean()` for numpy arrays. We
have learned about a few functions that get passed things and don't belong to a specific object
(e.g., `print()`, `sum()`, and `len()`), but these are actually pretty rare in Python.

There are pros and cons to object-oriented languages vs. functional languages. If you're interested
in learning more about this, check out this web page:
[Functional Programming vs OOP](https://www.educative.io/blog/functional-programming-vs-oop)

## Creating our own classes

So far we've been using Python's built-in classes, such as lists, dictionaries, strings, and so on.
These are powerful, but as programs grow in size and complexity, they aren't always enough on their
own. Imagine writing a program to simulate a neural network. You might need to keep track of each
neuron's activation level, its connections to other neurons, and the weights on those connections.
In principle, you could store all of this information in separate lists and dictionaries, but that
can get messy quickly. A `Neuron` class, on the other hand, would allow us to bundle all of the data
and behavior for a single neuron into one object.

Custom classes like `Neuron` help in a few important ways, including organization, reusability, and
abstraction. In particular, abstraction allows us to hide complicated details behind a simple
interface. For example, other parts of your program don't need to know _how_ a neuron updates itself
— they would just need to call `neuron.update()`. This makes it much easier to build large programs
piece by piece.

You'll see all of these benefits firsthand later in the book when we build projects like experiments
and simulations. For now, let's start with the basics of how to define a class.

Creating a class in Python is easy.

```python
class Animal:
    def __init__(self, species):
        self.species = species

my_animal = Animal("dog")
print(my_animal)
print(my_animal.species)
```

Which generates the output:

```text
<__main__.Animal object at 0x101309810>
dog
```

The first print statement is what happens when we print the class itself. This just gives us some
difficult to read information about the name of the class, and some memory information about where
it is stored in your RAM (that's the `0x101309810` hexadecimal number; yours will likely be
different).

> [!NOTE]
>
> ### Memory addresses
>
> RAM, or Random Access Memory, is the part of your computer that stores data temporarily while
> programs are running. When you create a Python object, like the `my_animal` object in the example
> above, the object is stored in RAM so that it can be accessed quickly while the program is
> running.
>
> Every object in Python, whether it's a number, string, list, or a custom class like `Animal`, is
> assigned a unique location in memory. This location is represented by a memory address, and it's
> what you see when you print the object without a custom string representation—such as
> `<__main__.Animal object at 0x101309810>`. The `0x101309810` is a hexadecimal number that tells
> you where, in RAM, that object is stored.
>
> This memory address allows Python to quickly reference and manipulate objects without needing to
> search for them, making programs faster and more efficient. When you're done with an object and
> it's no longer needed, Python's garbage collector will eventually remove it from memory to free up
> space.

Below, let's walk through four other important things about the class definition above.

## Class definitions

When we declare a class, we use the `class` keyword, and then provide the name of our class.
Standard Python naming rules apply (don't start with numbers, no spaces, etc.). When naming a class,
a convention is to start it with upper-case, and to use "PascalCase" (i.e., concatenate words
without underscores, and capitalize the start of each word).

<br>

## Instances of a class

In the line:

```python
my_animal = Animal("dog")
```

we create an instance of the class. Notice how this is very similar to the way we create instances
of built in Python data types:

```python
my_float = float(5)
my_set = set('doggy')
my_array = np.array([1, 2, 3, 4, 5])
```

In each case we create an instance variable that we name whatever we want, and assign to it the name
of the class. When we create the instance, we can pass it information that the class will use when
the instance is created.

<br>

## The `__init__()` function in a class

A class usually has an `__init__()` function (often pronounced "dunder init"). This is the function
that runs when you create an instance of the class, as we do here. When the instance is created, any
code in the `__init__()` function is run. Think of it like the `main()` function for setting up that
object.

> [!TIP]
>
> ### Constructors
>
> The `__init__()` function is sometimes called the "constructor" of the class, as it's a method
> that's called when an instance of the class is created. Other languages have similar
> functionality, but the name or syntax is usually different. For example, in JavaScript the
> equivalent function is `constructor()`, while in Ruby it's `initialize()`.

<br>

## Using "self" in classes

The final thing to notice about class definitions is that they use a special kind of variable to
denote attributes and methods that belong to an instance of the class. This is the `self` parameter,
which you put before any variable in the class. You can almost think of `self` as like a dictionary
that stores all the data in the class, but instead of accessing the data using
`self[variable_name]`, you use `self.variable_name`. We only use `self` before a variable name
inside of a class. When we are outside a class dealing with one of its instances, we instead use the
instance name that we created (in this case, `my_animal`) and put that before the variable name to
access that variable.

The other thing to notice about `self` is that we must include it as the first parameter in each
function (method) inside of a class, as we did in the `__init__()` function.

<!-- GITHUB-NAV-START -->

Next: [6.1. Class Attributes](6.1.%20Class%20Attributes.md)<br>
Previous: [5.6. Lab 5](../CH05/5.6.%20Lab%205.md)

<!-- GITHUB-NAV-END -->
