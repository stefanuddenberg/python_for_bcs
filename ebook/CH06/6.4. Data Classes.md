# 6.4. Data Classes

Data classes, introduced in Python 3.7, give you a convenient way to write classes that mostly
*store data*. They can automatically generate common methods like `__init__()`, `__repr__()`, and
`__eq__()`, so you get a nice, readable class without writing a bunch of boilerplate.

Before we talk about data classes, we need a quick detour into type hints.

## Type hints

Type hints are a way to *annotate* what type of data you expect a variable to hold. Python usually
won't enforce these types at runtime, but your code editor (and optional tools like type checkers)
can use them to point out mistakes early. Here's a simple example:

```python
name: str = "Alice"
age: int = 30
is_alive: bool = True
```

In this example, we're telling our editor that `name` should be a string, `age` should be an
integer, and so on. If we try to assign a different type of value later, many editors will flag it
(for example, with squiggly red underlines).

Type hints are optional when writing data classes, but they're worth using: they make the class
definition self-documenting, and they help your tools help you.

You can also use type hints for more complex data types, like lists and dictionaries, or even
custom classes.

```python
name: str = "Alice"
age: int = 30
is_alive: bool = True

favorite_colors: list[str] = ["red", "blue", "green"]
favorite_numbers: dict[str, int] = {"Alice": 1, "Bob": 2, "Charlie": 3}
# assume the existence of an Animal class declared earlier
favorite_animal: Animal = Animal("Dog", True, True, True)
```

Don't stress too much over type hints: you can always add them later.
We also touch on type hints in
[Chapter 8.1. Style and Readability](../CH08/8.1.%20Style%20and%20Readability.md), 
and you can read more about them in the [Python documentation](https://docs.python.org/3/library/typing.html).

## Basic data class

Here's a simple example of a data class:

```python
from dataclasses import dataclass

@dataclass
class Animal:
    name: str
    is_alive: bool
    can_move: bool
    can_grow: bool
```

These few lines of code are equivalent to writing all of this:

```python
class Animal:
    def __init__(self, name: str, is_alive: bool, can_move: bool, can_grow: bool):
        self.name = name
        self.is_alive = is_alive
        self.can_move = can_move
        self.can_grow = can_grow

    def __repr__(self):
        return f"Animal(name={self.name}, is_alive={self.is_alive}, can_move={self.can_move}, can_grow={self.can_grow})"

    def __eq__(self, other):
        if not isinstance(other, Animal):
            return NotImplemented
        return (self.name, self.is_alive, self.can_move, self.can_grow) == (
            other.name,
            other.is_alive,
            other.can_move,
            other.can_grow,
        )
```

In addition to being more concise, defining `Animal` as a data class gives us the ability to print
out instances in a more readable format, as well as compare two `Animal` instances with `==`.

## Features and options

### Default values

Data classes can have default values, which can be quite helpful:

```python
from dataclasses import dataclass

@dataclass
class Rectangle:
    width: float
    height: float = 1.0  # default value given if none is provided
    color: str = "white"

my_rectangle = Rectangle(width=10) # width is required, but height and color have defaults
print(my_rectangle) # prints out: Rectangle(width=10, height=1.0, color='white')
```

### Frozen instances

You can keep the data in your data class from changing (i.e. make your class immutable) by using the
`frozen=True` option:

```python
@dataclass(frozen=True)
class Configuration:
    host: str
    port: int = 8080

my_configuration = Configuration(host="localhost")

```

Attempting to modify a frozen instance will raise `FrozenInstanceError`.

```python
my_configuration.host = "127.0.0.1" # dataclasses.FrozenInstanceError: cannot assign to field 'host'
```

### Post-init processing

Although you won't generally want to write an `__init__` method for every data class, you can use
the `__post_init__` method to perform additional initialization beyond the default:

```python
@dataclass
class Person:
    first_name: str
    last_name: str
    full_name: str | None = None # `full_name` can be a string or the value `None`

    def __post_init__(self):
        if self.full_name is None:
            self.full_name = f"{self.first_name} {self.last_name}"


person = Person(first_name="John", last_name="Doe")
print(person) # prints out: Person(first_name='John', last_name='Doe', full_name='John Doe')
```

### Field options

The `field()` function provides additional control over fields, allowing you to specify more complex
default values on creation. For example, consider a `Student` class where we want to automatically
assign an id number to each student. We can accomplish this with data classes like this:

```python
from dataclasses import dataclass, field
from typing import ClassVar

@dataclass
class Student:
    name: str
    grades: list[int] = field(
        default_factory=list
    )  # Use default_factory for mutable defaults
    id: int = field(init=False, default=0)  # Field not included in __init__ — don't provide it at creation!
    _id_counter: ClassVar[int] = 0 # class-level counter shared by all students

    def __post_init__(self):
        # Assign an ID, then increment the shared counter
        self.id = Student._id_counter
        Student._id_counter += 1


alex = Student(name="Alex")
print(alex) # prints out: Student(name='Alex', grades=[], id=0)

bill = Student(name="Bill")
print(bill) # prints out: Student(name='Bill', grades=[], id=1) # notice that the id is automatically assigned

charlie = Student(name="Charlie", grades=[95, 87, 92])
print(charlie) # prints out: Student(name='Charlie', grades=[95, 87, 92], id=2)
```

## When should you use a data class?

Data classes work well when you have a class that is mostly about storing a handful of fields —
something like a `Point`, a `Configuration`, or a `Student` record. You get `__init__()`,
`__repr__()`, and `__eq__()` for free, and you can freeze the object if you don't want it to change.

On the other hand, if your class does a lot of *work* (e.g., it has many methods, uses inheritance
heavily, or needs unusual control over how instances get created) then a regular class may be easier
to reason about. Data classes aren't wrong in those situations, but they stop saving you much effort
once you're overriding most of the defaults.

### Data classes vs. named tuples vs. regular classes

You might wonder how data classes compare to some other related data structures we've already
encountered.

**Named tuples** (see [Chapter 2.6. Tuples](../CH02/2.6.%20Tuples.md) for a review) are lighter
weight and always immutable, but they're also less flexible — you can't add methods, and you can't
give fields default values as easily.

```python
from collections import namedtuple

Point = namedtuple('Point', ['x', 'y'])
p = Point(x=10, y=20)
print(p) # prints out: Point(x=10, y=20)
```

**Regular classes** give you the most control, but at the cost of writing more boilerplate code.

```python
class Person:
    def __init__(self, name: str, age: int):
        self.name = name
        self.age = age

class Student(Person):
    def __init__(self, name: str, age: int, grade: int):
        super().__init__(name, age)
        self.grade = grade
```

So, data classes sit somewhere in between the two in terms of conciseness and flexibility.

### A few tips

- Type hints in data classes follow the pattern `variable_name: type = value` (for example,
  `name: str = "Alex"`). Try to include them on every field, as they can serve as built-in
  documentation.
- If the data must never change after creation, add `frozen=True` to the decorator. This is handy
  for things like configuration objects.
- Watch out for mutable defaults! Writing `grades: list[int] = []` will share a *single* list across
  all instances. Use `field(default_factory=list)` instead. See also the section on mutable default
  arguments in 
  [Chapter 8.8. Common Pitfalls](../CH08/8.8.%20Common%20Pitfalls.md#mutable-default-arguments) 
  for more on this issue.
- Finally, remember that `__post_init__()` is there when you need to compute or validate something
  right after the object is created. This can be useful for things like building a `full_name` from
  `first_name` and `last_name`, as we saw earlier.

Next: [6.5. Turtle](6.5.%20Turtle.md)<br>
Previous: [6.3. Class Inheritance](6.3.%20Class%20Inheritance.md)
