# 1.6 Operators

_Operators_ are a part of programming languages (and math) that are used to perform operations on a variable. Python has
many kind of operators, we will cover the basics here and bring up others as they become relevant.

## Arithmetic Operators

Arithmetic operators perform simpler arithmetic.

```python
x = 3
y = 4

z = x + y  ## addition, resulting in 7
z = x - y  ## subtraction, resulting in -1
z = x * y  ## multiplication, resulting in 12
z = x / y  ## division, resulting in 0.75
z = x % y  ## modulus (the remainder of division), resulting in 3
z = x // y  ## floor division (division without the remainder), resulting in 0
z = x ** y  ## exponentiation, resulting in 81
```

## Assignment Operators

Assignment operators involve assigning a value to a variable. This includes the simple assignment (=). But assignment
can also be combined with many of the other operators.

```python
x = 12  ## simple assignment

x += 5  ## adds 5 to x, resulting in 17. shorter way of writing x = x - 4
x -= 5  ## subtracts 5 from x, resulting in 7
x *= 5  ## multiplies x by 5, resulting in 60
x /= 5  ## divides x by 5, resulting in 2.4
x %= 5  ## stores the remainder of x/5 in x, resulting in 2
x //= 5  ## stores the non-remainder value of x/5 in x, resulting in 2
x **= 5  ## stores 12 raised to the 5th power in x, resulting in 248832
```

## Comparison Operators

Comparison operators compare two values or variables, and return a boolean (True or False).

```python
x = 5
x == 7  # tests if x is equal to 7, and so evaluates to False
x != 7  # tests if x is not equal to 7, and so returns True
x > 7  # tests if x is greater than 7, and so evaluates to False
x < 7  # tests if x is less than 7, and so evaluates to True
x >= 7  # tests if x is greater or equal to 7, and so evaluates to False
x <= 7  # tests if x is less than or equal to 7, and so evaluates to True

y = [1, 2, 3]
z = [1, 2, 3]
y == z  # evaluates to True because the values are the same
y is z  # evaluates to False because the variables point to different objects in memory
```

> [!TIP]
>
> #### `==` vs `is`
>
> The double equals sign `==` is used to check whether two values are equivalent. The `is` operator,
> on the other hand, is used to compare the _identities_ of two variables. In other words, `==`
> checks if the values are the same, while `is` checks if the variables point to the same object in
> memory. As we saw above:
>
> ```python
> y = [1, 2, 3]
> z = [1, 2, 3]
> y == z  # True
> y is z  # False
> ```
>
> You'll use `==` to compare most types of values, but `is` comes up regularly, especially when
> working with objects, booleans, and `None`, especially when combined with conditionals (which
> we'll learn more about in the next section).
>
> ```python
> x = None
> if x is not None:
>     print("x is not None")
> ```

### Comparing strings lexicographically

You can also compare strings with `<`, `>`, `<=`, and `>=`. For strings, these comparisons are
**lexicographic** (English dictionary-like): Python compares the first character of each string,
then the next character if needed, moving left-to-right until it can decide which one comes first.

```python
name1 = "Alice"
name2 = "Bob"
name1 == "Alice"  # evaluates to True because the strings match exactly
name1 != name2    # evaluates to True because the strings are different

# Lexicographic comparison (like in an English dictionary)
"cat" < "dog"     # evaluates to True because 'c' comes before 'd' in the alphabet
"cat" > "car"     # evaluates to True because 't' comes after 'r' in the alphabet
"cat" < "cats"    # evaluates to True because "cat" is shorter and matches up to its length

# Case matters! Capital letters come *before* lowercase in Unicode/ASCII
"Cat" < "cat"     # evaluates to True because uppercase 'C' comes before lowercase 'c'
"zebra" > "Zebra" # evaluates to True because lowercase 'z' comes after uppercase 'Z'

# Python compares strings character by character, left to right
"apple10" < "apple2"  # evaluates to False because '1' comes before '2' in ASCII
```

## Logical Operators

Logical operators (e.g., `and`, `or`, and `not`) combine or modify *boolean expressions* (those that
evaluate to `True` or `False`; recall  
[Chapter 1.5](1.5.%20Bool,%20Binary,%20and%20None%20Data%20Types.md)). Logical operators like `and`
and `or` evaluate left-to-right and may stop early once the overall result is determined (this is
called *short-circuiting*).

```python
x = 5
y = 2
x < 5 and y < 5  # evaluates to False because it requires that both expressions be True, and the first is not
x < 5 or y < 5  # evaluates to True because at least one expression is True
not(x < 5 or y < 5)  # evaluates to False because it negates the value within parentheses
```

### On truthiness

In Python (and many other languages) values can be "truthy" or "falsy". Truthy values are those that
are considered "True" in a boolean context, while falsy values are the opposite (they behave like
"False"). This means that if you cast the value to a boolean, it will be `True` if the value is
truthy, and `False` if the value is falsy. Here are some common examples:

- Truthy values:
  - Any non-empty string (e.g., `bool("dog")` is `True`, as is `bool("a")` or `bool("0")`)
  - Any non-zero number (e.g., `bool(1)` is `True`, as is `bool(0.001)`)
  - Any non-empty collection (e.g., list, tuple, set, dictionary). For example, `bool([1, 2, 3])` or
    `bool(("a", "b", "c"))` or `bool({"a": 1, "b": 2, "c": 3})`
- Falsy values:
  - `0` (zero), so `bool(0)` is `False`
  - `None`, so `bool(None)` is also `False`
  - The empty string `""`, so `bool("")` is `False`
  - Empty collections (e.g., empty list, tuple, set, dictionary), so `bool([])` is `False`

Sometimes, however, truthy/falsy values behave quite differently from `True` and `False` themselves.
For example, if used in the context of a Boolean expression (as with `"cat" and "dog"`), the `and`
and `or` expressions evaluate to the first truthy/falsy value; they do not evaluate to `True` or
`False`!

```python
a = "cat" and "dog"   # x becomes "dog" (both are truthy, so it evaluates to the last value)
b = "" and "dog"      # y becomes "" (stops early because "" is falsy; doesn't bother evaluating the second value)

c = "cat" or "dog"    # c becomes "cat" (stops early because it's an `or` expression and `"cat"` is truthy)
d = "" or "dog"       # d becomes "dog" ("" is falsy, so it evaluates to the second value in an `or` expression)
```

## Membership Operators

The membership operator tests to see if an element is in a collection (like a string, or lists, sets, and dictionaries
as we will learn about later) and returns a boolean value.

```python

x = "the dog chased the cat."
"g" in x  # will evaluate to True, because there is a "g" in the string x.
"dog" not in x   # will evaluate to False, because "dog" is in x, and not negates
```

## Bitwise Operators

Python has many other operators for dealing with binary strings. We are not going to cover those in this class, but more
information can be found here: https://realpython.com/python-bitwise-operators/.

## Order of Operations

One useful thing to know is that in Python, order of operations follow strict rules so that you can look at a complex
expression with multiple operations and know which comes first. This is like how in math, `3 + 4 * 2` is equal to `11`,
and not `14`, because we do the multiplication before the division. But because there are many more operators in Python,
the rules are more complex. The table below shows some of the most common operators, and the order in which they are
evaluated.

| Operator               | Description                                       |
| ---------------------- | ------------------------------------------------- |
| ( )                    | Parentheses are highest precedence                |
| x\[index\]             | Indexing a string or a list                       |
| \*\*                   | Exponentiation                                    |
| -x                     | Negating a variable                               |
| \* / // %              | Multiplication, Division, Modulus, Floor Division |
| + -                    | Addition, Subtraction                             |
| &                      | Bitwise AND                                       |
| ^                      | Bitwise XOR                                       |
| \|                     | Bitwise OR                                        |
| in, not in, is, is not | Identity and membership                           |
| \=\=, \!\=             | Testing equality                                  |
| <, <=, >, >=           | Comparison                                        |
| not x                  | Boolean NOT                                       |
| and                    | Boolean AND                                       |
| or                     | Boolean OR                                        |
| if-else                | Conditional                                       |
| \=                     | Assignment                                        |

## Exercise: Operator Evaluation

What will each of the following expressions evaluate to? Make predictions before you try to run each line in the interpreter. Compare your predictions to the actual results — what did you get wrong? Can you trace the logic to figure out why things turned out different than how you expected?

```python
# Arithmetic Operators
x = 10
y = 3
x + y
x - y
x * y
x / y
x % y
x // y
x ** y

# Assignment Operators
x = 5
x += 3
x -= 2
x *= 4
x /= 2
x %= 5
x //= 2
x **= 2

# Comparison Operators
a = 5
b = 7
a == b
a != b
a > b
a < b
a >= b
a <= b

# String Comparisons
"apple" < "banana"
"Apple" < "apple"
"cat" < "cats"
"10" < "2"

# Logical Operators
x = True
y = False
x and y
x or y
not x
not y
x and not y
not (x or y)

# Membership Operators
text = "Python Programming"
"Python" in text
"python" in text
"python" in text.lower()
"gram" in text
"Java" not in text

# Complex Expressions (Order of Operations)
2 + 3 * 4
(2 + 3) * 4
2 ** 3 * 4
2 ** (3 * 4)
10 / 2 * 3
10 / (2 * 3)
```

<details>
<summary>Exercise Solution — expand only when you're ready</summary>

```python
# Arithmetic Operators
x = 10
y = 3
x + y    # 13
x - y    # 7
x * y    # 30
x / y    # 3.3333333333333335 -- what a curious 5 at the end!
x % y    # 1
x // y   # 3
x ** y   # 1000

# Assignment Operators
x = 5
x += 3   # x == 8
x -= 2   # x == 6
x *= 4   # x == 24
x /= 2   # x == 12.0 -- note that this is now a float!
x %= 5   # x == 2.0
x //= 2  # x == 1.0
x **= 2  # x == 1.0

# Comparison Operators
a = 5
b = 7
a == b   # False
a != b   # True
a > b    # False
a < b    # True
a >= b   # False
a <= b   # True

# String Comparisons
# These all evaluate to True because the strings are lexicographically less than the strings they are compared to
# (e.g., "apple" comes before "banana" in the dictionary, 1 comes before 2, and so on)
"apple" < "banana"
"Apple" < "apple"
"cat" < "cats"
"10" < "2"

# Logical Operators
x = True
y = False
x and y      # False
x or y       # True
not x        # False
not y        # True
x and not y  # True
not (x or y) # False

# Membership Operators
text = "Python Programming"
"Python" in text          # True
"python" in text          # False
"python" in text.lower()  # True
"gram" in text            # True
"Java" not in text        # True

# Complex Expressions (Order of Operations)
2 + 3 * 4     # 14
(2 + 3) * 4   # 20
2 ** 3 * 4    # 32
2 ** (3 * 4)  # 4096
10 / 2 * 3    # 15.0 — again, a float!
10 / (2 * 3)  # 1.6666666666666667
```

</details>

Next: [1.7. Conditionals](1.7.%20Conditionals.md)<br>
Previous: [1.5. Bool, Binary, and None Data Types](1.5.%20Bool,%20Binary,%20and%20None%20Data%20Types.md)
