# 4.2 Sequence tricks

Now that we have covered all of our basic data types in Python, let's talk about a few more tricks.

## Sorting data structures

We've already sorted lists. You can use the same trick to sort sets and dictionaries.

Now remember that sets are not ordered, so sorting it converts it into a list.

```python
my_animals = {'dog', 'lion', 'mouse', 'cat'}
sorted_animals = sorted(my_animals)
print(sorted_animals)
# results in ['cat', 'dog', 'lion', 'mouse']
```

It sorts alphabetically, as you can see above. You can sort in reverse by adding the `reverse=True`
argument.

```python
my_animals = {'dog', 'lion', 'mouse', 'cat'}
sorted_animals = sorted(my_animals, reverse=True)
print(sorted_animals)
# results in ['mouse', 'lion', 'dog', 'cat']
```

You can sort dictionaries too, but it is a little more complicated since dictionaries contain
key-value pairs. But remember that we can use the `.keys()`, `.values()`, and `.items()` methods to
get lists of the keys, values, or key-value pairs. We can then sort them the same way we do lists.

```python
animal_populations = {'dog': 471000000, 'cat': 600000000, 'bee': 2000000000000, 'human': 8000000000}
animals = sorted(animal_populations.keys())
populations = sorted(animal_populations.values())
populations = sorted(animal_populations.items())
```

Remember that `.items()` creates tuples with the key and then the value, so this will sort the tuples by the key. But if
we wanted them sorted by the value we can do that too:

```python
animal_populations = {'dog': 471000000, 'cat': 600000000, 'bee': 2000000000000, 'human': 8000000000}
sorted(animal_populations.items(), key=lambda item: item[1])
```

It's quite common to sort using lambda functions rather than fully fledged functions. (For a review
of lambda functions, see the eponymous section in [Chapter 3.0](../CH03/3.0.%20Functions.md).)
Basically, we can use this lambda expression to say what we want to sort the tuples by. Using
`item[1]` sorts by the second slot, the values from the dictionary. Using `item[0]` would have
sorted by the keys. And of course, it doesn't matter what we call the parameter in the lambda
function, so long as we're consistent. We could have used `x` instead of `item` and it would have
worked equally well.

## Comprehensions

Although we gave a couple of examples of list comprehensions in 
[Chapter 1.0.](../CH01/1.0.%20Python%20Statements%20&%20Expressions.md), 
we didn't cover them in detail because they require that you understand how loops work 
first. Now that you've learnt how to use loops, we can revisit them and see how they can 
be used to simplify the creation of collections.

### List comprehensions

Let's begin by way of example. Suppose that you want to create a list of the squares of only
the even numbers from 1 to 5. We can accomplish this easily using a for loop:

```python
squares = []
for i in range(1, 6):
    if i % 2 == 0:
        squares.append(i**2)
print(squares) # [4, 16]
```

This is a perfectly cromulent way to get the squares of the even numbers, and for many other languages, this may even be the best way to do it. However, in Python we can do a little better. Consider the following:

```python
squares = [i**2 for i in range(1, 6) if i % 2 == 0]
print(squares) # [4, 16]
```

What did we just do? By reorganizing the components of the for loop, we were able to get the same
result using a single line of code where it previously took 4. Whenever you see a pattern like the
one above, you should immediately think about substituting it with a comprehension. 

Let's make the pattern even clearer. When you see something like this:

```python
empty_collection = [] # make an empty collection
for i in range(start, end): # loop over something in a sequence
    if some_condition_is_met: # (optional) condition to filter the items
    empty_collection.append(i) # add to the collection
```

You can substitute it with this:
```python
# create and populate the collection in one line
empty_collection = [i for i in range(start, end) if some_condition_is_met] 
```

You can also add conditions to the comprehension to filter the items (as we did in the even squares
example above), or even have multiple loops when you need to iterate over multiple sequences at
once; the pattern remains the same. Consider the case where you want to set up coordinates in a
two-dimensional (2D) grid, with columns denoted by letters (A-D) and rows denoted by numbers (1-4):

```python
coords = []
for column in 'ABCD':
    for row in range(1, 5):
        coords.append((column, row))
print(coords)

# gives us our 2D grid of coordinates, though of course printed on one long line;
# I'm breaking it up here for readability.
# [('A', 1), ('A', 2), ('A', 3), ('A', 4), 
# ('B', 1), ('B', 2), ('B', 3), ('B', 4), 
# ('C', 1), ('C', 2), ('C', 3), ('C', 4),
# ('D', 1), ('D', 2), ('D', 3), ('D', 4)]
```
You can instead write this as a comprehension:

```python
coords = [(column, row) for column in 'ABCD' for row in range(1, 5)]
print(coords)

# same result as above!
# notice that here we have two loops and no conditional statement
```

There is no practical limit to how many clauses, loops, and conditionals you can squeeze into a
comprehension, but it's not recommended to go overboard. Think of a single line of code as a single
sentence you can express in natural language. You can, of course, say a sentence that is extremely
long with several nested clauses, but then it becomes difficult to understand. So too it is with
code. Stick to two or three clauses max when using comprehensions.

Comprehensions are a general pattern in the language that can be applied to any type of collection.
Below we'll go over how we can use comprehensions to create dictionaries, sets, and lastly,
generator expressions, which operate a little differently from the others.

### Dictionary comprehensions

Dictionary comprehensions look very similar to list comprehensions, substituting dictionaries for lists.

```python
squares = {i: i**2 for i in range(1, 6)}
print(squares)  # {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}

even_squares = {i: i**2 for i in range(1, 6) if i % 2 == 0}
print(even_squares)  # {2: 4, 4: 16}
```

### Set comprehensions

As you might expect by now, set comprehensions have the same sort of syntax:

```python
even_squares = {i**2 for i in range(1, 6) if i % 2 == 0}
print(even_squares)  # {4, 16}
```


### Generator expressions

Above we saw examples of creating whole collections from scratch using comprehensions. However,
sometimes the collections you might want to create are so big that they won't fit in your computer's
limited memory. When that happens, you wouldn't want to create the whole collection at once, because
it would be too heavy. Rather, you can tell the interpreter, "This is the pattern that the sequence
should follow, and I want to access these one at a time, without storing them all at once".
Generator expressions (accomplished with round parentheses) allow us to do that by means of lazy
evaluation; the values won't be computed until they are needed.

```python
squares = (i**2 for i in range(1, 6))
print(squares)  # <generator object <genexpr> at 0x00000247C4A39A40>

even_squares = (i**2 for i in range(1, 6) if i % 2 == 0)
print(even_squares)  # <generator object <genexpr> at 0x00000247C49535E0>
```

The tricky part about working with these expressions is that you can't see inside of them directly.
If you try to print them, you'll see something like the above, where you can see a "generator
object" at a particular memory address. You also can't index into them directly (e.g., `squares[4]`
will raise a `TypeError`). But we can make use of them in the context of a loop:

```python
squares = (i**2 for i in range(1, 6))
for square in squares:
    print(square) # 1, 4, 9, etc., printed one at a time on separate lines without commas
```

Or by using the `next()` function:

```python
squares = (i**2 for i in range(1, 6))
print(next(squares)) # 1
print(next(squares)) # 4
print(next(squares)) # 9
print(next(squares)) # 16
print(next(squares)) # 25
```

Or by using functions that expect an iterator object like `list()` or `sum()`:

```python
squares = (i**2 for i in range(1, 6))
print(list(squares)) # [1, 4, 9, 16, 25]

# need to create the generator again here, otherwise it will be empty!
squares = (i**2 for i in range(1, 6))
print(sum(squares)) # 55
```

Once you exhaust the generator expression, it will raise a `StopIteration` exception, so you can't
iterate over it again. This is why I had to create `squares` twice above! If I had just done it
once, then by the second time I tried to use it, the output would be empty (meaning that the sum
would amount to 0 in the above case).

To sum up, comprehensions are perhaps the most unique and powerful feature of Python, and can be
found all over the place. Be aware of the type of brackets you use when working with them: square
brackets create lists, curly braces create dictionaries (or sets, depending on the syntax), and
round brackets create generator expressions.

<!-- GITHUB-NAV-START -->

Next: [4.3. JSON Files](4.3.%20JSON%20Files.md)<br>
Previous: [4.1. Dictionaries](4.1.%20Dictionaries.md)

<!-- GITHUB-NAV-END -->
